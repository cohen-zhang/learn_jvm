# Java 类

## 虚拟机如何加载 Java 类的（生命周期）？

- 1. 加载 Loading

> 在这个阶段，JVM 的主要目的是将字节码从各个位置（网络、磁盘等）转化为二进制字节流加载到内存中，接着会为这个类在 JVM 的方法区创建一个对应的 Class 对象，这个 Class 对象就是这个类各种数据的访问入口。 其实加载阶段用一句话来说就是：把代码数据加载到内存中。

- 2. 验证
- 3. 链接：准备、解析；
- 4. 初始化
- 5. 使用
- 6. 卸载

## Java Class 文件

- 1. 魔数
- 2. 版本号
- 3. 常量池
- 4. 访问标志
- 5. 类索引、父类索引、接口索引集合
- 6. 字段表集合
- 7. 方法表集合
- 8. 属性表集合

## 类加载器

- 1. 启动类加载器 Bootstrap ClassLoader
- 2. 扩展类加载器 Extension ClassLoader
- 3. 应用程序类加载器 Application ClassLoader
- 4. 自定义类加载器

## 类加载器的双亲委派模型

- 1. 什么是双亲委派模型？
- 2. 为什么要使用双亲委派模型？
因为 Java 的类加载器是层次化的，每个类加载器都有自己的父类加载器，这样就形成了一个类加载器的树状结构，这个树状结构就是双亲委派模型的体现。
可以确保 Java 核心库的类型安全：所有的 Java 应用都至少会引用 java.lang.Object 类，也就是说在运行期，java.lang.Object 这个类会被加载到 Java 虚拟机中；如果这个加载过程是由 Java 应用自己的类加载器来完成的，那么很可能就会在JVM中存在多个版本的 java.lang.Object 类，而且这些类之间还是不兼容的，互相不可见的（正是命名空间在发挥着作用），相互之间的调用会失败。借助于双亲委派机制，Java 核心类库中的类的加载工作都是由启动类加载器来统一完成，从而确保了 Java 应用所使用的都是同一个版本的 Java 核心类库，他们之间是相互兼容的。
- 3. 双亲委派模型的工作流程
工作流程如下：如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成，每一个层次的类加载器都是如此，因此所有的加载请求最终都应该传送到顶层的启动类加载器中，只有当父类加载器反馈自己无法完成这个加载请求（它的搜索范围中没有找到所需的类）时，子加载器才会尝试自己去加载。



## 参考

[《深入理解 Java 虚拟机》6.3 章节，Class 类文件的结构](https://time.geekbang.org/column/article/6523)