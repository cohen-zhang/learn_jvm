# Java 类加载机制

## 虚拟机如何加载 Java 类的（生命周期）？

- 1. 加载 Loading

> 在这个阶段，JVM 的主要目的是将字节码从各个位置（网络、磁盘等）转化为二进制字节流加载到内存中，接着会为这个类在 JVM 的方法区创建一个对应的 Class 对象，这个 Class 对象就是这个类各种数据的访问入口。 其实加载阶段用一句话来说就是：把代码数据加载到内存中。

- 2. 验证
  定义：验证是为了确保 Class 文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。
  举例：
  1）. 文件格式验证：验证字节流是否符合 Class 文件格式的规范，比如是否以 0xCAFEBABE 开头、主次版本号是否在当前虚拟机处理范围之内等。
  2). 元数据验证：对字节码描述的信息进行语义分析，以保证其描述的信息符合 Java 语言规范的要求。


- 3. 链接：准备、解析；
  链接定义：链接是把类的二进制数据合并到 JRE 中的过程。
  准备：为类的静态变量分配内存并设置类变量初始值的阶段，这些内存都将在方法区中进行分配。
  解析：把类中的符号引用转换为直接引用的过程。
  什么是符合引用：这些符合引用都直接或间接地引用了当前类或者其他类的信息，这些信息都存在于常量池中。
  什么是直接引用：直接引用就是直接指向目标的指针、相对偏移量或一个间接定位到目标的句柄（handle）。
  在实际使用中，符号引用主要出现在以下三个地方：
    - 1. 类或接口的全限定名，比如 java.lang.Object
    - 2. 字段的名称和描述符，比如 name、Ljava/lang/String;
    - 3. 类方法的名称和描述符，比如 main、([Ljava/lang/String;)V

- 4. 初始化
  定义：初始化是类加载过程的最后一步，是执行类构造器 <clinit>() 方法的过程。
- 5. 使用
  定义：使用阶段是执行程序主方法的过程。
- 6. 卸载
  定义：卸载阶段是在程序执行结束后，JVM 卸载这个类的过程。

## Java Class 文件

- 1. 魔数
- 2. 版本号
- 3. 常量池
- 4. 访问标志
- 5. 类索引、父类索引、接口索引集合
- 6. 字段表集合
- 7. 方法表集合
- 8. 属性表集合

## 类加载器

- 1. 启动类加载器 Bootstrap ClassLoader
- 2. 扩展类加载器 Extension ClassLoader
- 3. 应用程序类加载器 Application ClassLoader
- 4. 自定义类加载器

## 类加载器的双亲委派模型

- 1. 什么是双亲委派模型？
- 2. 为什么要使用双亲委派模型？
因为 Java 的类加载器是层次化的，每个类加载器都有自己的父类加载器，这样就形成了一个类加载器的树状结构，这个树状结构就是双亲委派模型的体现。
可以确保 Java 核心库的类型安全：所有的 Java 应用都至少会引用 java.lang.Object 类，也就是说在运行期，java.lang.Object 这个类会被加载到 Java 虚拟机中；如果这个加载过程是由 Java 应用自己的类加载器来完成的，那么很可能就会在JVM中存在多个版本的 java.lang.Object 类，而且这些类之间还是不兼容的，互相不可见的（正是命名空间在发挥着作用），相互之间的调用会失败。借助于双亲委派机制，Java 核心类库中的类的加载工作都是由启动类加载器来统一完成，从而确保了 Java 应用所使用的都是同一个版本的 Java 核心类库，他们之间是相互兼容的。
- 3. 双亲委派模型的工作流程
工作流程如下：如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成，每一个层次的类加载器都是如此，因此所有的加载请求最终都应该传送到顶层的启动类加载器中，只有当父类加载器反馈自己无法完成这个加载请求（它的搜索范围中没有找到所需的类）时，子加载器才会尝试自己去加载。

## 参考

[《深入理解 Java 虚拟机》6.3 章节，Class 类文件的结构](https://time.geekbang.org/column/article/6523)